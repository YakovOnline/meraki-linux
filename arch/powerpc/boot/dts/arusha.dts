/*
 * Device Tree Source for APM (AM86xxx) Arusha WAP Reference Design Board
 *
 * Copyright (c) 2010 Applied Micro Circuits Corporation.
 * All rights reserved. Pranavkumar Sawargaonkar <psawargaonkar@apm.com>.
 *
 * This file is licensed under the terms of the GNU General Public
 * License version 2.  This program is licensed "as is" without
 * any warranty of any kind, whether express or implied.
 */

/dts-v1/;

/ {
	#address-cells = <2>;
	#size-cells = <1>;
	model = "apm,apm862xx";
	compatible = "apm,apm862xx";
	dcr-parent = <&{/cpus/cpu@0}>;

	aliases {
		serial0 = &UART0;
 
		ethernet0 = &enet0;
                ethernet1 = &enet1;
	};

	cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		cpu@0 {
			device_type = "cpu";
			model = "PowerPC,APM86xxx";
			reg = <0>;
			clock-frequency = <0>; /* Filled in by U-Boot */
			plb-frequency = <0>; /* Filled in by U-Boot */
			timebase-frequency = <0>; /* Filled in by U-Boot */
			i-cache-line-size = <32>;
			d-cache-line-size = <32>;
			i-cache-size = <32768>;
			d-cache-size = <32768>;
			dcr-controller;
			dcr-access-method = "native";
/*			next-level-cache = <&L2C0>;
*/
			#address-cells = <1>;
			#size-cells = <0>;
/*
			L2C0: l2-cache@400000000 {
				compatible = "apm,l2-cache";
				status = "enabled";
				dcr-reg = <0x000 0x002>;
				cache-line-size = <0x20>;	
				cache-size = <0x40000>;		
				reg = <0x4 0x00000000 0x00000>;	
			};
*/		
		};
		
		cpu@1 {              
			device_type = "cpu";
			model = "PowerPC,APM86xxx";
			reg = <1>;
			clock-frequency = <0>; /* Filled in by U-Boot */
			plb-frequency = <0>; /* Filled in by U-Boot */
			timebase-frequency = <0>; /* Filled in by U-Boot */
			i-cache-line-size = <32>;
			d-cache-line-size = <32>;
			i-cache-size = <32768>;
			d-cache-size = <32768>;
			dcr-controller;
			dcr-access-method = "native";
/*			next-level-cache = <&L2C1>;
*/
			#address-cells = <1>;
			#size-cells = <0>;
/*
			L2C1: l2-cache@400040000 {
				compatible = "apm,l2-cache";
				status = "enabled";
				dcr-reg = <0x000 0x002>;
				cache-line-size = <0x20>;	
				cache-size = <0x40000>;		
				reg = <0x4 0x00040000 0x00000>;	
			};
*/			
		};
	};

	memory {
		device_type = "memory";
		reg = <0x00000000 0x00000000 0x00000000>; /* Filled in by U-Boot */
	};

	OCM1: ocm@effff8000 {
		compatible = "apm,ocm";
		status = "enabled";
		cell-index = <1>;
		reg = < 0xd 0xdd850000 0x1000   
			0xe 0xffff8000 0x8000>; 
		ipp-size = <0x400>;
		qm-size = <0x2000>;
        };

	SDU0: sdu@ddd810000 {
		compatible = "apm,apm86xxx-sdu";
		reg = <0xd 0xdd810000 0x10000>;
		interrupt-parent = <&mpic>;
		interrupts = <0 2>;
	};	

	hbf {
		compatible = "apm,hbf-am862xx", "apm,hbf";
		#address-cells = <2>;
		#size-cells = <1>;
		ranges;
		clock-frequency = <0>; /* Filled in by U-Boot */

                mpic: pic@df400000 {
                        clock-frequency = <0>;
                        interrupt-controller;
                        reg = <0xd 0xdf400000 0x40000>;
			#address-cells = <0>;
                        #interrupt-cells = <2>;
                        compatible = "chrp,open-pic";
                        device_type = "open-pic";
                        big-endian;
                };                

		ipp: ipp@ddd8b0000 {
			compatible = "apm,ipp";
			reg = <0xd 0xdd8b0000 0x1000>;
			interrupt-parent = <&mpic>; 
			interrupts = <  0x9 2  
					0xa 2 >;
		};
/*		
		msi@ddf407000 {
			compatible = "apm,apm86xxx-msi", "apm,mpic-msi";
			reg = <0xd 0xdf407000 0x200>;
			msi-available-ranges = <0x0 0x100>;
			interrupts = <
				0x3b 0
				0x3c 0
				0x3d 0
				0x3e 0
				0x3f 0
				0x40 0
				0x41 0
				0x42 0
				0x43 0
				0x44 0
				0x45 0
				0x46 0
				0x47 0
				0x48 0
				0x49 0
				0x4a 0>;
			interrupt-parent = <&mpic>;
		};

		msi_cascade@ddf407000 {
			compatible = "apm,apm86xxx-msi", "apm,mpic-msi-cascade";
			reg = <0xd 0xdf407000 0x200>;
			msi-available-ranges = <0x0 0x100>;
			num_irqs_per_reg = <32>;
			interrupts = <
				0x4b 0
				0x4c 0
				0x4d 0>;
			interrupt-parent = <&mpic>;
		};
*/ 
		PCIE0: pciex@500000000 {
			device_type = "pci";
			compatible = "apm862xx-pciex", "apm,apm-pciex";
			#interrupt-cells = <1>;
			#size-cells = <2>;
			#address-cells = <3>;
			primary;
			port = <0>;
			status = "ok";
			reg = < 0x6 0xd0000000 0x00100000
				0xd 0xdd880000 0x00008000>;

			ranges = <0x02000000 0x0 0x00000000 0x6 0x00000000 0x0 0x10000000
				  0x02000000 0x0 0x80000000 0x6 0x80000000 0x0 0x10000000
				  0x01000000 0x0 0x10000000 0x6 0x10000000 0x0 0x00010000>;


			dma-ranges = <0x42000000 0x0 0x00000000 0x0 0x00000000 0 0x80000000>;

			bus-range = <0x0 0x1f>;

			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
			interrupt-map = <
				0x0 0x0 0x0 0x1 &mpic 0x33 0x2 
				0x0 0x0 0x0 0x2 &mpic 0x34 0x2 
				0x0 0x0 0x0 0x3 &mpic 0x35 0x2 
				0x0 0x0 0x0 0x4 &mpic 0x36 0x2 >;
		};

		PCIE1: pciex@700000000 {
			device_type = "pci";
			compatible = "apm862xx-pciex", "apm,apm-pciex";
			#interrupt-cells = <1>;
			#size-cells = <2>;
			#address-cells = <3>;
			primary;
			port = <1>; /* port number */
			status = "ok";
                        reg = < 0x7 0xd1000000 0x00100000 /* Cfg registers */
                                0xd 0xdd890000 0x00008000>;   /* CSR registers */

                        /* Outbound ranges, one memory and one IO,
                         * <type> <pci> <cpu> <size>
                         */
                        ranges = <0x02000000 0x0 0x00000000 0x7 0x00000000 0x0 0x10000000
                                  0x02000000 0x0 0x80000000 0x7 0x80000000 0x0 0x10000000
                                  0x01000000 0x0 0x10000000 0x7 0x10000000 0x0 0x00010000>;


                        /* Inbound 2GB range starting at 0
                         * <type> <pci> <cpu> <size>
                         */
                        dma-ranges = <0x42000000 0x0 0x00000000 0x0 0x00000000 0 0x80000000>;

                        /* This drives busses 0x20 to 0x3f */
                        bus-range = <0x20 0x3f>;
			/* Legacy interrupts (note the weird polarity, the bridge seems
			* to invert PCIe legacy interrupts).
			* We are de-swizzling here because the numbers are actually for
			* port of the root complex virtual P2P bridge. But I want
			* to avoid putting a node for it in the tree, so the numbers
			* below are basically de-swizzled numbers.
			* The real slot is on idsel 0, so the swizzling is 1:1
			*/
                        interrupt-map-mask = <0x0 0x0 0x0 0x7>;
                        interrupt-map = <
                                0x0 0x0 0x0 0x1 &mpic 0x37 0x2 /* swizzled int A */
                                0x0 0x0 0x0 0x2 &mpic 0x38 0x2 /* swizzled int B */
                                0x0 0x0 0x0 0x3 &mpic 0x39 0x2 /* swizzled int C */
                                0x0 0x0 0x0 0x4 &mpic 0x3a 0x2 /* swizzled int D */>;

		};

		PCIE2: pciex@A00000000 {
			device_type = "pci";
			compatible = "apm862xx-pciex", "apm,apm-pciex";
			#interrupt-cells = <1>;
			#size-cells = <2>;
			#address-cells = <3>;
			primary;
			port = <2>; /* port number */
			status = "ok";
                        reg = < 0xA 0xd1000000 0x00100000 /* Cfg registers */
				0xd 0xdd8F0000 0x00008000>;   /* CSR registers */

                        /* Outbound ranges, one memory and one IO,
                         * <type> <pci> <cpu> <size>
                         */
                        ranges = <0x02000000 0x0 0x00000000 0xA 0x00000000 0x0 0x10000000
                                  0x02000000 0x0 0x80000000 0xA 0x80000000 0x0 0x10000000
                                  0x01000000 0x0 0x10000000 0xA 0x10000000 0x0 0x00010000>;


                        /* Inbound 2GB range starting at 0
                         * <type> <pci> <cpu> <size>
                         */
                        dma-ranges = <0x42000000 0x0 0x00000000 0x0 0x00000000 0 0x80000000>;

                        /* This drives busses 0x20 to 0x3f */
                        bus-range = <0x20 0x3f>;
			/* Legacy interrupts (note the weird polarity, the bridge seems
			* to invert PCIe legacy interrupts).
			* We are de-swizzling here because the numbers are actually for
			* port of the root complex virtual P2P bridge. But I want
			* to avoid putting a node for it in the tree, so the numbers
			* below are basically de-swizzled numbers.
			* The real slot is on idsel 0, so the swizzling is 1:1
			*/
                        interrupt-map-mask = <0x0 0x0 0x0 0x7>;
                        interrupt-map = <
                                0x0 0x0 0x0 0x1 &mpic 0x26 0x2 /* swizzled int A */
                                0x0 0x0 0x0 0x2 &mpic 0x27 0x2 /* swizzled int B */
                                0x0 0x0 0x0 0x3 &mpic 0x28 0x2 /* swizzled int C */
                                0x0 0x0 0x0 0x4 &mpic 0x29 0x2 /* swizzled int D */>;
		};

		gpt0: timer@df4010f0 {
			compatible = "apm,apm86xxx-gpt";
			reg = <0xd 0xdf4010f0 0x220>;
			interrupts = <243 0 244 0 245 0 246 0>;
			interrupt-parent = <&mpic>;
		};

		gpt1: timer@df4020f0 {
			compatible = "apm,apm86xxx-gpt";
			reg = <0xd 0xdf4020f0 0x220>;
			interrupts = <247 0 248 0 249 0 250 0>;
			interrupt-parent = <&mpic>;
		};

                qmtm: qmtm@dd800000 {
                        device_type = "qmtm";
                        compatible = "mb-qmtm", "apm,mb-qmtm";
                        #interrupt-cells = <2>;
                        reg = <0xd 0xdd800000 0x10000   
                               0xd 0xdf000000 0x400000  
                               0x3 0xffffd000 0x3fff	
                               0xd 0x00000000 0x400000  
                               0xd 0xdd8d0000 0x10000	
                               0xd 0xdd8b1000 0x240>;	
                        interrupt-parent = <&mpic>;
                        interrupts = <  0x21 2  0x5 2 0x11 2 0x12 2 0x13 2 0x14 2 0x15 2 0x16 2 0x17 2
                                        0x18 2 0x19 2 0x1a 2 0x1b 2 0x1c 2 0x1d 2 0x1e 2 0x1f 2
                                        0x20 2>;
			maxqid = <255>;
			qstart = <1>;
			dma-reg = <0x0 0x0 0x0>;			 
                };
/*
		SRAM0: sram@0x020000000 {
			compatible = "mtd-ram";
			reg = <0x0 0x20000000 0x2000000>; 
			bank-width = <2>;
			#size-cells = <1>;
			#address-cells = <1>;
			partition@0 {
				label = "MTD-RAM Root FS 0";
				reg = <0x00000000 0x01000000>;
			};
			partition@1 {
				label = "MTD-RAM Root FS 1";
				reg = <0x01000000 0x01000000>;
			};
		};
*/
		enet0: ethernet@dd8a0000 {
			device_type = "network";
			compatible = "apm, apm86xxx-enet";
			interrupt-parent = <&mpic>;
			interrupts = <0x22 2      
                                      0x23 2      
                                      0x2B 2 >;  
			reg = <0xd 0xdd8a0000 0x200     
			       0xd 0xdd8e0000 0x10000   
                               0xd 0xdd8a0800 0xF800>;  
			local-mac-address = [1a2a3a4a5a60]; 
			max-frame-size = <0x233a>;
			devid = <0>;
                };
                
	        enet1: ethernet@dd8a0030 {
			device_type = "network";
			compatible = "apm, apm86xxx-enet";
			interrupt-parent = <&mpic>;
			interrupts = <0x22 2      
                                      0x23 2      
                                      0x2B 2 >;  
			reg = <0xd 0xdd8a0030 0x200     
			       0xd 0xdd8e0000 0x10000   
                               0xd 0xdd8a0800 0xF800>;  
			local-mac-address = [1a2a3a4a5a61]; 
			max-frame-size = <0x233a>;
			devid = <1>;
                };

		pktdma: pktdma@dd820000 {
			device_type = "dma";
			compatible = "apm-pktdma", "apm,apm86xxx-pktdma";
			#interrupt-cells = <1>;
			reg = <0xd 0xdd820000 0x10000 >;
			interrupt-parent = <&mpic>;
			ch-info = <0 1 2 3>;
			fp-info = <6>;
		};
/*
		crypto: crypto@ddd830000 {
			device_type = "crypto";
			compatible = "apm,apm86xxx-crypto";
			#interrupt-cells = <1>;
			reg = <0xd 0xdd830000 0x8000>; 
			interrupt-parent = <&mpic>;
		};
*/
		rtc:	rtc@d00410000 {
			device_type = "rtc";
			compatible = "apm-apm86xxx-rtc";
			reg = <0xd 0x00410000 0x400>;
			interrupt-parent = <&mpic>;
			interrupts = <0x30 2>;
		};
		SATA:	sata@500000000 {
			device_type = "sata";
			compatible = "sata-ahci", "apm,sata-ahci";
			phy = <1>;
			reg = <0x5 0x00000000 0x4000
			       0xd 0xdd877000 0x3000
			       0xd 0xdd870000 0x7000
			       0xd 0xdd880000 0x10000>;
			interrupt-parent = <&mpic>;
			interrupts = <0x2c 2>;
		};
/*
		lcd: lcd@ddf440000 {
			device_type = "lcd";
			compatible = "apm,apm-lcd";
			reg = <0xd 0xdf440000 0x2000>;
			interrupt-parent = <&mpic>;
			interrupts = <0x7 2>;
			overlay = <3>;
			frame = <2>;
		};
*/		
		AHB0: ahb {
			device_type = "ahb";
			compatible = "apm,ahb";
			#address-cells = <2>;
			#size-cells = <1>;
			ranges;
			clock-frequency = <0>; /* Filled in by U-Boot */

	                ahbc@ddd860000 {
	                        device_tpye = "ahbc";
                        	compatible = "apm,apm86xxx-ahbc";
				reg = <0xd 0xdd860000 0x10000>;
		        };

			ufc@ffc000000 {
				compatible = "apm,ufc";
				#address-cells = <2>;
				#size-cells = <1>;
				ranges;
				clock-frequency = <0>; 
				interrupt-parent = <&mpic>;
				interrupts = <6 1>;

				nor_flash@0,0 {
					compatible = "cfi-flash";
					bank-width = <2>;
					reg = <0xf 0xfc000000 0x4000000>;
					#address-cells = <1>;
					#size-cells = <1>;
					partition@0 {
						label = "OS";
						reg = <0x00000000 0x01600000>;
					};
					partition@1 {
						label = "Filesystem";
						reg = <0x01600000 0x02960000>;
					};
					partition@2 {
						label = "Environment";
						reg = <0x03f60000 0x00040000>;
					};
					partition@3 {
						label = "U-Boot";
						reg = <0x03fa0000 0x00060000>;
					};
				};

			};

			USB0: usb@fa0100000 {
				device_type = "usb";
				compatible = "apm,usb-otg";
				reg = <0xf 0xa0100000 0x40000>;
				interrupt-parent = <&mpic>;
				interrupts = <0x4f 2>;
				devid = <0>;
				/* To force mode, add
				 * mode = "host"; OR
				 * mode = "device";
				 */
			};

			USB1: ehci@fa0010400 {
				compatible = "apm,usb-ehci-460ex", "usb-ehci";
				reg = <0xf 0xa0010400 0x90 0xf 0xa0010490 0x70>;
				interrupt-parent = <&mpic>;
				interrupts = <0x5f 4>;
				devid = <1>;
			};

/*
			USB2: usb@fa0010000 {
				compatible = "apm,usb-ohci-460ex", "usb-ohci","ohci-le";
				reg = <0xf 0xa0010000 0x60>;
				interrupt-parent = <&mpic>;
				interrupts = <0x2a 4>;
				devid = <1>;
			};

			USB2: ehci@fa0010c00 {
				compatible = "apm,usb-ehci-460ex", "usb-ehci";
				reg = <0xf 0xa0010c00 0x90 0xf 0xa0010c90 0x70>;
				interrupt-parent = <&mpic>;
				interrupts = <0x2e 4>;
				devid = <2>;
			};

			USB2: usb@fa0010800 {
				compatible = "apm,usb-ohci-460ex", "usb-ohci","ohci-le";
				reg = <0xf 0xa0010800 0x60>;
				interrupt-parent = <&mpic>;
				interrupts = <0x2f 4>;
				devid = <2>;
			};

			sdhc0: sdhc@fa0040000 {
				device_type = "sdhc";
				compatible = "apm,apm-sdhc";
				#interrupt-cells = <1>;
				slot = <0>;
				reg = <0xf 0xa0040000 0x100
					0xd 0xdd862000 0x8000>;
				interrupt-parent = <&mpic>;
				interrupts = <0x59 2>;
			};

			sdhc1: sdhc@fa0040100 {
				device_type = "sdhc";
				compatible = "apm,apm-sdhc";
				#interrupt-cells = <1>;
				slot = <1>;
				reg = <0xf 0xa0040100 0x100
					0xd 0xdd862000 0x8000>;
				interrupt-parent = <&mpic>;
				interrupts = <0x59 2>;
			};
*/
			APB0: apb {
				compatible = "apm,apb";
				device_type = "apb";
				#address-cells = <2>;
				#size-cells = <1>;
				ranges;
				clock-frequency = <0>; /* Filled in by U-Boot */

				UART0: serial@fa0000000 {
					device_type = "serial";
					compatible = "ns16550";
					reg = <0xf 0xa0000000 0x1000>;
					reg-shift = <2>;
					clock-frequency = <0>; /* Filled in by U-Boot */
					current-speed = <0xe100>;
					interrupt-parent = <&mpic>;
					interrupts = <0xb 2>;
				};
/*	
				UART1: serial@fa0001000 {
					device_type = "serial";
					compatible = "ns16550";
					reg = <0xf 0xa0001000 0x1000>;
					reg-shift = <2>;
					clock-frequency = <0>;
					current-speed = <0xe100>;
					interrupt-parent = <&mpic>;
					interrupts = <0xc 2>;
				};
				
				UART2: serial@fa0007000 {
					device_type = "serial";
					compatible = "ns16550";
					reg = <0xf 0xa0007000 0x1000>;
					reg-shift = <2>;
					clock-frequency = <0>; 
					current-speed = <0x1c200>;
					interrupt-parent = <&mpic>;
					interrupts = <0xd 2>;
				};
				
				UART3: serial@fa0008000 {
					device_type = "serial";
					compatible = "ns16550";
					reg = <0xf 0xa0008000 0x1000>;
					reg-shift = <2>;
					clock-frequency = <0>; 
					current-speed = <0x1c200>;
					interrupt-parent = <&mpic>;
					interrupts = <0xe 2>;
				};
*/				
/*
				I2C0:	i2c@fa0002000 {
					device_type = "i2c";
					compatible = "apm,apm86xxx-i2c";
					reg = <0xf 0xa0002000 0x1000>;
					clock-frequency = <100000000>;
					interrupt-parent = <&mpic>;
					interrupts = <0xf 2>;
				};
				
				SPI0:	spi@fa0005000 {
				 	device_type = "spi";
					compatible = "apm,spi";
					#address-cells = <1>;
					#size-cells = <0>;
					reg = <0xf 0xa0005000 0x1000>;
					interrupt-parent = <&mpic>;
					interrupts = <0x52 2>;
					sysclk = <62000000>;
					bus_num = <0x0>;

					SFLASH: m25p80@0 {
						compatible = "stm,m25p80","jedec-flash";
						reg = <0>;
						spi-max-frequency = <3100000>;
						spi-cpha;
						spi-cpol;
					};
				};

				SPI1:	spi@fa0006000 {
				 	device_type = "spi";
					compatible = "apm,spi";
					reg = <0xf 0xa0006000 0x1000>;
					interrupt-parent = <&mpic>;
					interrupts = <0x6 2>;
					sysclk = <62000000>;
					bus_num = <0x1>;
				};

				GPIO:	gpio@fa0004000 {
					device_type = "gpio";
					compatible = "apm,apm86xxx-gpio";
					reg = <0xf 0xa0004000 0x1000>;
					gpio-count = <0x1a>;
				};
*/
			};

		};
	};
	chosen {
		linux,stdout-path = "/hbf/ahb/apb/serial@fa0000000";
	};
};
